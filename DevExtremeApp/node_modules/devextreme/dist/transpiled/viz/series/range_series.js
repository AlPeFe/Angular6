"use strict";

// there are rangebar, rangearea

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var extend = require("../../core/utils/extend").extend,
    _extend = extend,
    _isDefined = require("../../core/utils/type").isDefined,
    _map = require("../core/utils").map,
    _noop = require("../../core/utils/common").noop,
    scatterSeries = require("./scatter_series").chart,
    barSeries = require("./bar_series").chart.bar,
    areaSeries = require("./area_series").chart.area;

exports.chart = {};

var baseRangeSeries = {

    areErrorBarsVisible: _noop,
    _createErrorBarGroup: _noop,

    _checkData: function _checkData(data) {
        return scatterSeries._checkData(data) && data.minValue !== undefined && data.minValue === data.minValue;
    },

    getValueRangeInitialValue: scatterSeries.getValueRangeInitialValue,

    _getPointDataSelector: function _getPointDataSelector(data) {
        var valueFields = this.getValueFields();
        var val1Field = valueFields[0];
        var val2Field = valueFields[1];
        var tagField = this.getTagField();
        var argumentField = this.getArgumentField();

        return function (data) {
            return {
                tag: data[tagField],
                minValue: data[val1Field],
                value: data[val2Field],
                argument: data[argumentField],
                data: data
            };
        };
    },

    _defaultAggregator: "range",

    _aggregators: {
        range: function range(_ref, series) {
            var _data$reduce;

            var intervalStart = _ref.intervalStart,
                data = _ref.data;

            if (!data.length) {
                return;
            }

            var valueFields = series.getValueFields();
            var val1Field = valueFields[0];
            var val2Field = valueFields[1];

            var result = data.reduce(function (result, item) {
                var val1 = item[val1Field];
                var val2 = item[val2Field];

                if (!_isDefined(val1) || !_isDefined(val2)) {
                    return result;
                }

                result[val1Field] = Math.min(result[val1Field], Math.min(val1, val2));
                result[val2Field] = Math.max(result[val2Field], Math.max(val1, val2));

                return result;
            }, (_data$reduce = {}, _defineProperty(_data$reduce, val1Field, Infinity), _defineProperty(_data$reduce, val2Field, -Infinity), _defineProperty(_data$reduce, series.getArgumentField(), intervalStart), _data$reduce));

            if (!isFinite(result[val1Field]) || !isFinite(result[val2Field])) {
                if (data.filter(function (i) {
                    return i[val1Field] === null && i[val2Field] === null;
                }).length === data.length) {
                    result[val1Field] = result[val2Field] = null;
                } else {
                    return;
                }
            }

            return result;
        }
    },

    getValueFields: function getValueFields() {
        return [this._options.rangeValue1Field || "val1", this._options.rangeValue2Field || "val2"];
    }
};

exports.chart["rangebar"] = _extend({}, barSeries, baseRangeSeries);

exports.chart["rangearea"] = _extend({}, areaSeries, {
    _drawPoint: function _drawPoint(options) {
        var point = options.point;

        if (point.isInVisibleArea()) {
            point.clearVisibility();
            point.draw(this._renderer, options.groups);
            this._drawnPoints.push(point);
            if (!point.visibleTopMarker) {
                point.hideMarker("top");
            }
            if (!point.visibleBottomMarker) {
                point.hideMarker("bottom");
            }
        } else {
            point.setInvisibility();
        }
    },

    _prepareSegment: function _prepareSegment(points, rotated) {
        var processedPoints = this._processSinglePointsAreaSegment(points, rotated),
            processedMinPointsCoords = _map(processedPoints, function (pt) {
            return pt.getCoords(true);
        });

        return {
            line: processedPoints,
            bottomLine: processedMinPointsCoords,
            area: _map(processedPoints, function (pt) {
                return pt.getCoords();
            }).concat(processedMinPointsCoords.slice().reverse()),
            singlePointSegment: processedPoints !== points
        };
    },

    _getDefaultSegment: function _getDefaultSegment(segment) {
        var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);
        defaultSegment.bottomLine = defaultSegment.line;
        return defaultSegment;
    },

    _removeElement: function _removeElement(element) {
        areaSeries._removeElement.call(this, element);
        element.bottomLine && element.bottomLine.remove();
    },

    _drawElement: function _drawElement(segment, group) {
        var that = this,
            drawnElement = areaSeries._drawElement.call(that, segment, group);
        drawnElement.bottomLine = that._bordersGroup && that._createBorderElement(segment.bottomLine, { "stroke-width": that._styles.normal.border["stroke-width"] }).append(that._bordersGroup);

        return drawnElement;
    },

    _applyStyle: function _applyStyle(style) {
        var that = this,
            elementsGroup = that._elementsGroup,
            bordersGroup = that._bordersGroup;

        elementsGroup && elementsGroup.smartAttr(style.elements);
        bordersGroup && bordersGroup.attr(style.border);
        (that._graphics || []).forEach(function (graphic) {
            graphic.line && graphic.line.attr({ "stroke-width": style.border["stroke-width"] });
            graphic.bottomLine && graphic.bottomLine.attr({ "stroke-width": style.border["stroke-width"] });
        });
    },

    _updateElement: function _updateElement(element, segment, animate, complete) {
        var bottomLineParams = { points: segment.bottomLine },
            bottomBorderElement = element.bottomLine;

        areaSeries._updateElement.apply(this, arguments);

        if (bottomBorderElement) {
            animate ? bottomBorderElement.animate(bottomLineParams) : bottomBorderElement.attr(bottomLineParams);
        }
    }
}, baseRangeSeries);